### General Interrrupt Information

There are 3 different types of interrupts:

1. NMI
2. RESET
3. IRQ

|Type|Vector Location|
|----|---------------|
|NMI|0xFFFA - 0xFFFB|
|RESET|0xFFFC - 0xFFFD|
|IRQ|0xFFFE - 0xFFFF|

The general process for handling an interrupt is as follows:

1. An interrupt request occurs (`requestedInterrupt = true`)
2. Finish the current CPU instruction.
3. Check if `requestedInterrupt = true`. 
4. If interrupt is requested:
    * Push the `PC`, and `P` registers on to the stack. In the following order:
        * PC LOW
        * PC HIGH
        * P
    * Load the location of the interrupt handler found in the vector location into the PC.
    * The CPU will then read the `PC` and resume at the interrupt handler pointed by the register. It will continue execution of the interrupt until `RTI` has occurred.
    * The `RTI` instruction in the interrupt handler will cause the CPU to pull the PC, and P registers from the stack and resume execution.
5. Resume program execution of the instruction at the addressed specified within the program counter.

For all interrupts, all will take **7 CPU cycles** to prepare for the interrupt before the interrupt handler is executed.

### Interrupt Priority

1. RESET
2. NMI
3. IRQ

### RESET

The Break bit is cleared during the reset interrupt.

### NMI

These are generated by the PPU when VBLANK occurs during each frame. This is the start of the 20 scanline cycle in which the CPU is allowed to write to PPU memory again. (Although nothing technically stops it from doing that to begin with...).

* Non-maskable interrupt. 
* The vector address is at 0xFFFA and 0xFFFB.

The process to generate the adddress is like:

```
handlerAddress = (mem.get(0xFFFB) << 8) | mem.get(0xFFFA)
```

So:

```
FFFA: E8
FFFB: C4
```

Then the handler address will be: `C4E8`. The program counter will be redirected there.

#### Terminology
* `NMI_occurred` refers to the flag set in bit 7 in the `$2002` PPUSTATUS register
 * `NMI_output` refers to bit 7 set in the `$2000` PPUCTRL register.

#### Occurrence
* The NMI is not controlled by the CPU, and is associated with VBLANK from the PPU. When it occurs and when it is done is seen in the following situations:

1. When the PPU starts the VBLANK phase (bit 7 of $2002), the `NMI_occurred` flag in PPU is set to `true`. 
    * The `NMI_occurred` flag is reset to `false` at the end of VBLANK.
2. When the `PPUSTATUS` register is read, the *current* `NMI_occured` value is returned in bit 7. Once it is returned, this bit is reset and `NMI_occurred` is set to `false`.
3. A write to `PPUCTRL` at bit 7 (`NMI_output`) during VBLANK, will force NMI to occur.

When NMI occurs, PPU stays out of the bus for 20 scanlines (2273 cycles). This allows the CPU to load the graphics data into memory.

Think of it as the period of time when the CPU can **write** to VRAM again.

#### Can an NMI be Prevented?

An NMI request can actually be blocked if and only if bit 7 of $2002/PPUSTATUS is off. We can then perform a check like so to actually request the NMI upon the start of a VBLANK:

**Pseudo Code**
```
if ((this._regPPUSTATUS & 0x80) > 0x0) {
    requestNmi();
}
```

### IRQ

Software generated. If the *interrupt disable* bit is set in the P register, then these are ignored by the CPU. `BRK` instruction will generate the IRQ. 

---

#### References

1. Nintendo Entertainment System Documentation - Version 1.0. Patrick Diskin, [Source](http://www.nesdev.com/NESDoc.pdf)
2. The Frame and NMIs. NesDev Wiki, [Source](https://wiki.nesdev.com/w/index.php/The_frame_and_NMIs)
3. PPU Programmer Reference. NesDev Wiki, [Source](https://wiki.nesdev.com/w/index.php/PPU_programmer_reference)